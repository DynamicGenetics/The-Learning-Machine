<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

    <title>The Learning Machine</title>

    <style>
      .links line {
        stroke: #999;
        stroke-opacity: 0.6;
      }

      .nodes circle {
        stroke: #fff;
        stroke-width: 1.5px;
      }

      .emoji-label {
        font-family: sans-serif;
        font-size: 14px;
        fill: #888;
      }

      text {
        font-family: sans-serif;
        font-size: 10px;
      }

    </style>
  </head>

  <body>
    <svg width="1400" height="800"></svg>
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script>

      d3.json("dummy.json").then(function(data) {

        const svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height");

        function color(d) { return d3.scaleOrdinal(d3.schemeCategory10)(d.group)}

        const links = data.links.map(d => Object.create(d));
        const nodes = data.nodes.map(d => Object.create(d));

        const cx = width/2;
        const cy = height/2;
        const gs = 150;

// Function to return vertices of a regular hexagon
        function hexagon(n, cx, cy, gs){
          switch(n){
            case 0:
              return [cx - gs, cy - (Math.sqrt(3)*gs)];
              break;
            case 1:
              return [cx + gs, cy - (Math.sqrt(3)*gs)];
              break;
            case 2:
              return [cx + 2 * gs, cy];
              break;
            case 3:
              return [cx + gs, cy + (Math.sqrt(3)*gs)];
              break;
            case 4:
              return [cx - gs, cy + (Math.sqrt(3)*gs)];
              break;
            case 5:
              return [cx - 2 * gs, cy];
              break;
          }
        }

// Destructuring assignment to emoji node locations
        [nodes[0].fx, nodes[0].fy] = hexagon(0,cx,cy,gs);
        [nodes[1].fx, nodes[1].fy] = hexagon(1,cx,cy,gs);
        [nodes[2].fx, nodes[2].fy] = hexagon(2,cx,cy,gs);
        [nodes[3].fx, nodes[3].fy] = hexagon(3,cx,cy,gs);
        [nodes[4].fx, nodes[4].fy] = hexagon(4,cx,cy,gs);
        [nodes[5].fx, nodes[5].fy] = hexagon(5,cx,cy,gs);

// Target circles for the emoji areas
        for(let i = 0; i < 6; i++){
          svg.append("circle")
            .attr("r",55)
            .attr("fill", "#EEE")
            .attr("cx", hexagon(i,cx,cy,gs)[0])
            .attr("cy", hexagon(i,cx,cy,gs)[1]);
        }

// Label the target emojis
        for(let i = 0; i < 6; i++){
          svg.append("text")
            .attr("class", "emoji-label")
            .text( nodes[i].id )
            .attr("text-anchor", "middle")
            .attr("x", hexagon(i,cx,cy,gs)[0])
            .attr("y", hexagon(i,cx,cy,gs)[1]+40);
        }

// Set up simulation
        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id))
            .force("charge", d3.forceManyBody().strength(-500))
            .force("center", d3.forceCenter(width / 2, height / 2));

        const link = svg.append("g")
          .attr("class", "links")
          .selectAll("line")
          .data(links)
          .join("line")
          .attr("stroke-width", 0);

        const node = svg.append("g")
          .attr("class", "nodes")
          .selectAll("g")
          .data(nodes)
          .join("g")
          .call(drag(simulation));

        const circles = node.append("circle")
          .attr("r", 15)
          .attr("fill", color);

        const imgs = node.append("image")
          .attr("xlink:href", d => d.image)
          .attr("height",d => {
            if (d.group === 1) {return 50}
            else {return 40}
          })
          .attr("width",d => {
            if (d.group === 1) {return 50}
            else {return 40}
          })
          .attr("x",d => {
            if (d.group === 1) {return -25}
            else {return -20}
          })
          .attr("y",d => {
            if (d.group === 1) {return -25}
            else {return -20}
          });

        simulation
            .on("tick", ticked);

        function ticked() {
          link
              .attr("x1", d => d.source.x)
              .attr("y1", d => d.source.y)
              .attr("x2", d => d.target.x)
              .attr("y2", d => d.target.y);

          node
              .attr("transform", d => `translate(${d.x}, ${d.y})`);
        }

        function drag(simulation) {

          function dragstarted(d) {
            if (d.group===1) {return};
            if (!d3.event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
          }

          function dragged(d) {
            if (d.group===1) {return};
            d.fx = d3.event.x;
            d.fy = d3.event.y;
          }

          function dragended(d) {
            if (d.group===1) {return};
            if (!d3.event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
          }

          return d3.drag()
              .on("start", dragstarted)
              .on("drag", dragged)
              .on("end", dragended);
        }

      });
    </script>
  </body>
</html>
