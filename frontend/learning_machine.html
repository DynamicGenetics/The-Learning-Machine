<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet"
          href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
          integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T"
          crossorigin="anonymous">

    <title>The Learning Machine</title>

    <style>
      .link {
           stroke: #999;
           /* stroke-opacity: 0.2; */
           stroke-opacity: 0;
      }

      .node circle {
          stroke: #fff;
          stroke-width: 7px;
          fill: #EEE;
      }

      .emoji-label {
          font-family: sans-serif;
          font-size: 14px;
          fill: #555;
      }

      .h1-label {
        font-family: sans-serif;
        font-size: 24px;
        fill: #000;
      }

      .description {
        font-family: sans-serif;
        font-size: 14px;
        color: #555;
      }

      #blurb {
        position: absolute;
        top: 66px;
        right: 50px;
        width: 350px;
        text-align: right;
      }

      #header {
        position: absolute;
        top: 24px;
        right: 50px;
        text-align: right;
      }

      text {
          font-family: sans-serif;
          font-size: 10px;
      }

    </style>
  </head>

  <body>
    <div id="header" class="h1-label">The Learning Machine</div>
    <div id="blurb" class="description">
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod
         tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim
         veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea
          commodo consequat. Duis aute irure dolor in reprehenderit in voluptate
           velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint
           occaecat cupidatat non proident, sunt in culpa qui officia deserunt
           mollit anim id est laborum.</p>
    </div>
    <svg width="1400" height="800"></svg>
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <!-- <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script> -->
    <!-- <script src="https://d3js.org/d3.v5.min.js"></script> -->
    <!-- <script src="https://d3js.org/d3.v4.min.js"></script> -->
    <script src="d3.min.js"></script>
    <script src="d8r.js"></script>
    <script>

      // *** Set up plotting area ***

      const svg = d3.select("svg"),
          width = +svg.attr("width"),
          height = +svg.attr("height");

      // Set up a clipPath for the images
      svg.append("clipPath")
          .attr("id", "clipCircle")
        .append("circle")
          .attr("r", 24)
          .attr("cx", 0)
          .attr("cy", 0);

      // Layout parameters
      const cx = 0;
      const cy = 0;
      const gs = 180;
      const numberOfFaces = 25;

      // Transition
      const t = svg.transition()
          .duration(1000);

      // Set up a colour palette for donut plots
      let colours = ["#E4324F", // happy
                     "#5BC7FA", // angry
                     "#F6CA45", // disgust
                     "#5FCE43", // fear
                     "#F19C38", // sad
                     "#6559A6"];// surprise

      // Target circle radius
      let targetr = 55;

      // Target circles for the emoji areas
      const hex = d8r.hexagonArray(cx, cy, gs);
      for (let i = 0; i < 6; i++) {
          svg.append("circle")
              .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
              .attr("r", targetr)
              .attr("fill", "#EEE")
              .attr("cx", hex[i].x)
              .attr("cy", hex[i].y)
              .attr("id", d8r.fixedNodeIDs[i] + "_target")
              .attr("stroke", colours[i])
              .attr("stroke-width", 3);
      }
      // Label the target emojis
      for (let i = 0; i < 6; i++) {
          svg.append("text")
              .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
              .attr("class", "emoji-label")
              .text(d8r.fixedNodeIDs[i])
              .attr("text-anchor", "middle")
              .attr("x", hex[i].x)
              .attr("y", hex[i].y + 40)
              .attr("pointer-events", "none");
      }

      // Refresh button
      svg.append("g")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
          .attr("id", "refresh")
        .append("circle")
          .attr("cx", hex[4].x - (4 * targetr))
          .attr("cy", hex[5].y)
          .attr("fill", "#EEE")
          .attr("r", targetr);

      svg.append("text")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
          .attr("id", "refresh-label")
          .attr("class", "emoji-label")
          .attr("text-anchor", "middle")
          .attr("x", hex[4].x - (4 * targetr))
          .attr("y", hex[5].y + 40)
          .text("refresh")
          .attr("pointer-events", "none");

      svg.append("image")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
          .attr("xlink:href", "refresh_alt2.svg")
          .attr("id", "refresh-image")
          .attr("x", hex[4].x - (4 * targetr) - 25)
          .attr("y", hex[5].y -25)
          .attr("height", 50)
          .attr("width", 50)
          .attr("pointer-events", "none");

      // Forget button
      svg.append("g")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
          .attr("id", "forget")
        .append("circle")
          .attr("cx", hex[4].x - (4 * targetr))
          .attr("cy", hex[5].y + (2.5 * targetr))
          .attr("fill", "#EEE")
          .attr("r", targetr);

      svg.append("text")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
          .attr("id", "forget-label")
          .attr("class", "emoji-label")
          .attr("text-anchor", "middle")
          .attr("x", hex[4].x - (4 * targetr))
          .attr("y", hex[5].y + 40 + (2.5 * targetr))
          .text("forget")
          .attr("pointer-events", "none");

      svg.append("g")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
        .append("circle")
          .attr("cx", hex[4].x - (4 * targetr))
          .attr("cy", hex[5].y + (2.5 * targetr))
          .attr("fill", "#FFF")
          .attr("r", 25)
          .attr("stroke", "#FFF")
          .attr("stroke-width", 7);

      svg.append("image")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
          .attr("xlink:href", "forget_alt.svg")
          .attr("id", "forget-image")
          .attr("x", hex[4].x - (4 * targetr) - 25)
          .attr("y", hex[5].y -25 + (2.5 * targetr))
          .attr("height", 50)
          .attr("width", 50)
          .attr("pointer-events", "none");

      // Info button
      svg.append("g")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
          .attr("id", "info")
        .append("circle")
          .attr("cx", hex[4].x - (4 * targetr))
          .attr("cy", hex[5].y + (5 * targetr))
          .attr("fill", "#EEE")
          .attr("r", targetr);

      svg.append("text")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
          .attr("id", "info-label")
          .attr("class", "emoji-label")
          .attr("text-anchor", "middle")
          .attr("x", hex[4].x - (4 * targetr))
          .attr("y", hex[5].y + 40 + (5 * targetr))
          .text("info")
          .attr("pointer-events", "none");

      svg.append("g")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
        .append("circle")
          .attr("cx", hex[4].x - (4 * targetr))
          .attr("cy", hex[5].y + (5 * targetr))
          .attr("fill", "#FFF")
          .attr("r", 25)
          .attr("stroke", "#FFF")
          .attr("stroke-width", 7);

      svg.append("image")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
          .attr("xlink:href", "info.svg")
          .attr("id", "info-image")
          .attr("x", hex[4].x - (4 * targetr) - 25)
          .attr("y", hex[5].y -25 + (5 * targetr))
          .attr("height", 50)
          .attr("width", 50)
          .attr("pointer-events", "none");

      // Neutral face target
      // svg.append("g")
      //     .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
          //.attr("id", "neutral")
      svg.append("circle")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
          .attr("id", "neutral")
          // .attr("cx", hex[4].x - (4 * targetr))
          // .attr("cy", hex[5].y + (2.5 * targetr))
          .attr("cx", hex[4].x - (4 * targetr))
          .attr("cy", hex[3].y - (2.5 * targetr))
          .attr("fill", "#EEE")
          .attr("r", targetr)
          .attr("stroke", "#CCC")
          .attr("stroke-width", 3);

      svg.append("g")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
        .append("circle")
          // .attr("cx", hex[4].x - (4 * targetr))
          // .attr("cy", hex[5].y + (2.5 * targetr))
          .attr("cx", hex[4].x - (4 * targetr))
          .attr("cy", hex[3].y - (2.5 * targetr))
          .attr("fill", "#FFF")
          .attr("r", 25)
          .attr("stroke", "#FFF")
          .attr("stroke-width", 7);

      svg.append("text")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
          .attr("id", "neutral-label")
          .attr("class", "emoji-label")
          .attr("text-anchor", "middle")
          // .attr("x", hex[4].x - (4 * targetr))
          // .attr("y", hex[5].y + 40 + (2.5 * targetr))
          .attr("x", hex[4].x - (4 * targetr))
          .attr("y", hex[3].y + 40 - (2.5 * targetr))
          .text("neutral")
          .attr("pointer-events", "none");

      svg.append("image")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
          .attr("xlink:href", "neutral.svg")
          .attr("id", "neutral-image")
          // .attr("x", hex[4].x - (4 * targetr) - 25)
          // .attr("y", hex[5].y -25 + (2.5 * targetr))
          .attr("x", hex[4].x - 25 - (4 * targetr))
          .attr("y", hex[3].y - 25 - (2.5 * targetr))
          .attr("height", 50)
          .attr("width", 50)
          .attr("pointer-events", "none");

      // Not a human target
      // svg.append("g")
      //     .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
          //.attr("id", "not-human")
      svg.append("circle")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
          .attr("id", "not-human")
          // .attr("cx", hex[4].x - (4 * targetr))
          // .attr("cy", hex[5].y + (5 * targetr))
          .attr("cx", hex[4].x - (4 * targetr))
          .attr("cy", hex[3].y)
          .attr("fill", "#EEE")
          .attr("r", targetr)
          .attr("stroke", "#CCC")
          .attr("stroke-width", 3);

      svg.append("g")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
        .append("circle")
          // .attr("cx", hex[4].x - (4 * targetr))
          // .attr("cy", hex[5].y + (2.5 * targetr))
          .attr("cx", hex[4].x - (4 * targetr))
          .attr("cy", hex[3].y)
          .attr("fill", "#FFF")
          .attr("r", 25)
          .attr("stroke", "#FFF")
          .attr("stroke-width", 7);

      svg.append("text")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
          .attr("id", "not-human-label")
          .attr("class", "emoji-label")
          .attr("text-anchor", "middle")
          // .attr("x", hex[4].x - (4 * targetr))
          // .attr("y", hex[5].y + 40 + (5 * targetr))
          .attr("x", hex[4].x - (4 * targetr))
          .attr("y", hex[3].y + 40 )
          .text("not human")
          .attr("pointer-events", "none");

      svg.append("image")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
          .attr("xlink:href", "robot.svg")
          .attr("id", "not-human-image")
          // .attr("x", hex[4].x - (4 * targetr) - 25)
          // .attr("y", hex[5].y -25 + (5 * targetr))
          .attr("x", hex[4].x - 25 - (4 * targetr))
          .attr("y", hex[3].y - 25 )
          .attr("height", 50)
          .attr("width", 50)
          .attr("pointer-events", "none");

      // Logos
      svg.append("image")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
          .attr("xlink:href", "University-of-Bristol.svg")
          .attr("id", "University-of-Bristol")
          // .attr("x", hex[4].x - (4 * targetr) - 25)
          // .attr("y", hex[5].y -25 + (5 * targetr))
          .attr("x", hex[1].x - targetr + 10)
          .attr("y", hex[2].y + 7)
          .attr("height", 50)
          // .attr("width", 50)
          .attr("pointer-events", "none");

      svg.append("image")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
          .attr("xlink:href", "Alan-Turing-Institute.svg")
          .attr("id", "Alan-Turing-Institute")
          // .attr("x", hex[4].x - (4 * targetr) - 25)
          // .attr("y", hex[5].y -25 + (5 * targetr))
          .attr("x", hex[1].x + (4 * targetr) - 30)
          // .attr("x", hex[1].x + 170)
          .attr("y", hex[2].y + 7)
          .attr("height", 50)
          // .attr("width", 50)
          .attr("pointer-events", "none");


      // *** End set up plotting area ***

      fetch(`http://localhost:8000/faces/${numberOfFaces}`)
          .then(response => response.json())
          .then((json) => {
              let nodesArray = d8r.preprocess(json);
              // Set up data
              let data = d8r.compileData(nodesArray);
              for(let i = 0; i < 6; i++){
                data.nodes[i].fx = hex[i].x
                data.nodes[i].fy = hex[i].y
              }

              // Set up simulation
              let simulation = d3.forceSimulation(data.nodes)
                  .force("charge", d3.forceManyBody().strength(-1000))
                  .force("link", d3.forceLink(data.links).id(d => d.id).strength(d => d.value))
                  .alphaTarget(1).on("tick", ticked);

              // Define link and node
              let g = svg.append("g").attr("transform", "translate(" + width / 2 + "," + height / 2 + ")")
              let link = g.append("g").selectAll(".link")
              let node = g.append("g").selectAll(".node")

              // Arcs for donut charts
              let arc = d3.arc().innerRadius(25).outerRadius(28);
              let pie = d3.pie()
                  .value(function (d) {
                      return d;
                  }).sort(null);

              function donuts(d) {
                let dataNode = d3.select(this);

                dataNode.selectAll(".arc")
                    .data(function(d){return pie(d.donut);})
                    .join(
                      enter => {
                        enter.append("path")
                          .attr("class","arc")
                          .attr("d", arc)
                          .style("fill", function(d,i){return colours[i]});
                      },
                      update => update,
                      exit => exit.remove
                    );
              }

              restart();

              // What happens when the simulation ticks
              function ticked() {
                link.attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
                node.attr("transform", d => `translate(${d.x}, ${d.y})`);
              }

              function restart() {
                // Apply the general update pattern to the nodes and links
                node = node.data(data.nodes, d => d.id)
                  .join(
                    enter => {
                      let thisNode = enter.append("g")
                        .attr("class","node")
                        .attr("id", d => d.id)
                        .call(drag(simulation));
                      thisNode.append("circle")
                        .attr("r", 25);
                      thisNode.append("image")
                        .attr("xlink:href", d => d.image)
                        .attr("clip-path",d => {
                          if (d.group === "target") {return ""}
                          else {return "url(#clipCircle)"}
                        })
                        .attr("height",d => {
                          if (d.group === "target") {return 50}
                          else {return 48}
                        })
                        .attr("width",d => {
                          if (d.group === "target") {return 50}
                          else {return 48}
                        })
                        .attr("x",d => {
                          if (d.group === "target") {return -25}
                          else {return -24}
                        })
                        .attr("y",d => {
                          if (d.group === "target") {return -25}
                          else {return -24}
                        });
                      thisNode.filter(d => (d.group === "data"))
                        .each(donuts);

                      thisNode.attr("opacity", 0)
                        .call(enter => enter.transition(t)
                        .attr("opacity", 1));
                      return thisNode;
                    },
                    update => update,
                    exit => exit.remove()
                  );

                link = link.data(data.links, d => d.source.id + "-" + d.target.id)
                  .join(
                    enter => enter.append("line").attr("class", "link"),
                    update => update,
                    exit => exit.remove()
                  );

                // Update and restart the simulation.
                simulation.nodes(data.nodes);
                simulation.force("link").links(data.links);
                simulation.alpha(0.3).restart();
              }

              function drag(simulation) {

                function dragstarted(d) {
                  if (d.group === "target") { return };
                  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
                  d.fx = d.x;
                  d.fy = d.y;
                }

                function dragged(d) {
                  if (d.group === "target") { return };
                  d.fx = d3.event.x;
                  d.fy = d3.event.y;
                }

                function dragended(d) {
                  if (d.group=== "target") { return };
                  if (!d3.event.active) simulation.alphaTarget(0);
                  for(let i = 0; i < 6; i++){
                    if(d8r.dist(data.nodes[i].fx,data.nodes[i].fy,d.fx,d.fy) < targetr){
                      // Send the label to the backend
                      sendToBackend(d.id, data.nodes[i].id);
                      // Make the target circle flash
                      let target = d3.select( "#" + data.nodes[i].id + "_target" );
                      target.transition(t).attr( "fill","#CCC" ).transition(t).attr( "fill", "#EEE" );
                    }
                  }
                  // Dropping on neutral and not human targets
                  let neutral_target = d3.select("#neutral");
                  // console.log(neutral_target.attr("id"));
                  let not_human_target = d3.select("#not-human")
                  // console.log(not_human_target);
                  if(d8r.dist(neutral_target.attr("cx"),neutral_target.attr("cy"),d.fx,d.fy) < targetr){
                    // Send the label to the backend
                    sendToBackend(d.id, neutral_target.attr("id"));
                    // Make the target circle flash
                    neutral_target.transition(t).attr( "fill","#CCC" ).transition(t).attr( "fill", "#EEE" );
                  }
                  if(d8r.dist(not_human_target.attr("cx"),not_human_target.attr("cy"),d.fx,d.fy) < targetr){
                    // Send the label to the backend
                    sendToBackend(d.id, not_human_target.attr("id"));
                    // Make the target circle flash
                    not_human_target.transition(t).attr( "fill","#CCC" ).transition(t).attr( "fill", "#EEE" );
                  }
                  d.fx = null;
                  d.fy = null;
                }

                return d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended);
              }

              // What happens when you click the refresh button
              const refreshButton = d3.select("#refresh");
              refreshButton.on("click", () => {
                refreshButton.select("circle")
                  .transition().duration(100)
                  .attr("fill","#CCC")
                  .transition().duration(100)
                  .attr("fill","#EEE");

                fetch(`http://localhost:8000/faces/${numberOfFaces}`)
                    .then(response => response.json())
                    .then((json) => {
                        nodesArray = d8r.preprocess(json);
                        // Set up data
                        data = d8r.compileData(nodesArray);
                        restart();
                })
                .catch((error) => {
                  console.error('Restart server error:', error);
                });
              });

              function sendToBackend(imageId, emolabel){
                  // Remove the dragged element
                  for(let i = 0; i < nodesArray.length; i++){
                    if(nodesArray[i].nodes[0].id === imageId){
                      nodesArray.splice(i, 1);
                    }
                  }
                  data = d8r.compileData(nodesArray);
                  restart();

                  let callObject = {
                    image_id: imageId,
                    label: emolabel,
                    new_nodes: 1, // Number of new nodes (in addition to current_nodes)
                    current_nodes: nodesArray.map(x => x.nodes[0].id)  // So the server knows which nodes to send updates for
                  };


                  // Send the update to the server and receive the response
                  fetch("http://localhost:8000/faces/annotate", {
                    method: 'POST',
                    headers: {
                      "accept": "application/json",
                      "Content-Type": "application/json"
                    },
                    body: JSON.stringify(callObject)
                  }).then((response) => response.json())
                  .then((myJson) => {
                    nodesArray = d8r.refreshNodeArray(nodesArray, d8r.preprocess(myJson));
                    data = d8r.compileData(nodesArray);
                    restart();
                  })
                  .catch((error) => {
                    console.error('Server call error:', error);
                  });
              }
      });

    </script>
  </body>
</html>
